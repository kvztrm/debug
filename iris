local Iris = loadstring(game:HttpGet("https://raw.githubusercontent.com/SirMallard/Iris/main/Iris.lua"))()
Iris.Init(game.CoreGui)  -- Change to PlayerGui if needed

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- States
local aimbotEnabled   = Iris.State(false)
local autoKillEnabled = Iris.State(false)
local espEnabled      = Iris.State(false)
local fovSize         = Iris.State(80)

-- Aimbot settings
local aimSettings = {
    aimPart   = "Head",
    smoothing = 0.05,
    wallCheck = false,
    teamCheck = false
}

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness    = 1
fovCircle.NumSides     = 64
fovCircle.Filled       = false
fovCircle.Color        = Color3.fromRGB(0, 255, 100)
fovCircle.Visible      = false

-- Target Info GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "TargetInfo"
screenGui.IgnoreGuiInset = true
screenGui.Parent = game.CoreGui
screenGui.ResetOnSpawn = false

local targetFrame = Instance.new("Frame", screenGui)
targetFrame.Size              = UDim2.new(0, 220, 0, 70)
targetFrame.Position          = UDim2.new(0.5, -110, 0, 50)
targetFrame.BackgroundColor3  = Color3.fromRGB(25, 25, 30)
targetFrame.BorderColor3      = Color3.fromRGB(0, 150, 255)
targetFrame.BorderSizePixel   = 2
targetFrame.Visible           = false

local profileImage = Instance.new("ImageLabel", targetFrame)
profileImage.Size                  = UDim2.new(0, 50, 0, 50)
profileImage.Position              = UDim2.new(0, 5, 0.5, -25)
profileImage.BackgroundColor3      = Color3.fromRGB(40, 40, 45)
profileImage.BorderSizePixel       = 0

local targetName = Instance.new("TextLabel", targetFrame)
targetName.Size                = UDim2.new(0, 160, 0, 22)
targetName.Position            = UDim2.new(0, 60, 0, 8)
targetName.BackgroundTransparency = 1
targetName.TextColor3          = Color3.fromRGB(255, 255, 255)
targetName.Font                = Enum.Font.GothamBold
targetName.TextSize            = 15
targetName.TextXAlignment      = Enum.TextXAlignment.Left
targetName.Text                = "TARGET: NONE"

local targetTeam = Instance.new("TextLabel", targetFrame)
targetTeam.Size                = UDim2.new(0, 160, 0, 18)
targetTeam.Position            = UDim2.new(0, 60, 0, 30)
targetTeam.BackgroundTransparency = 1
targetTeam.TextColor3          = Color3.fromRGB(150, 150, 150)
targetTeam.Font                = Enum.Font.Gotham
targetTeam.TextSize            = 12
targetTeam.TextXAlignment      = Enum.TextXAlignment.Left
targetTeam.Text                = "TEAM: NONE"

local healthBg = Instance.new("Frame", targetFrame)
healthBg.Size                = UDim2.new(0, 155, 0, 8)
healthBg.Position            = UDim2.new(0, 60, 0, 50)
healthBg.BackgroundColor3    = Color3.fromRGB(50, 50, 50)
healthBg.BorderSizePixel     = 0

local healthFill = Instance.new("Frame", healthBg)
healthFill.Size                  = UDim2.new(1, 0, 1, 0)
healthFill.BackgroundColor3      = Color3.fromRGB(0, 200, 100)
healthFill.BorderSizePixel       = 0

local healthText = Instance.new("TextLabel", targetFrame)
healthText.Size                = UDim2.new(0, 155, 0, 15)
healthText.Position            = UDim2.new(0, 60, 0, 59)
healthText.BackgroundTransparency = 1
healthText.TextColor3          = Color3.fromRGB(200, 200, 200)
healthText.Font                = Enum.Font.Code
healthText.TextSize            = 11
healthText.TextXAlignment      = Enum.TextXAlignment.Right
healthText.Text                = "100 HP"

-- Box ESP tables/functions (simplified from your GitHub rip)
local espDrawings = {}

local function worldToScreen(worldPoint)
    local screenPos, onScreen = Camera:WorldToViewportPoint(worldPoint)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen
end

local function isSameTeam(player)
    if not aimSettings.teamCheck then return false end
    local myTeam = LocalPlayer.Team
    if not myTeam then return false end
    return player.Team and player.Team == myTeam
end

local function createPlayerESP(player)
    if espDrawings[player] or player == LocalPlayer or isSameTeam(player) then return end

    local box = Drawing.new("Square")
    box.Thickness    = 2
    box.Color        = Color3.fromRGB(255, 50, 50)
    box.Filled       = false
    box.Visible      = false

    local hpLine = Drawing.new("Line")
    hpLine.Thickness    = 3
    hpLine.Color        = Color3.fromRGB(0, 255, 0)
    hpLine.Visible      = false

    local name = Drawing.new("Text")
    name.Size     = 13
    name.Color    = Color3.fromRGB(255, 255, 255)
    name.Center   = true
    name.Outline  = true
    name.Visible  = false

    local hpNum = Drawing.new("Text")
    hpNum.Size     = 12
    hpNum.Color    = Color3.fromRGB(255, 255, 255)
    hpNum.Center   = true
    hpNum.Outline  = true
    hpNum.Visible  = false

    local distanceTxt = Drawing.new("Text")
    distanceTxt.Size     = 10
    distanceTxt.Color    = Color3.fromRGB(180, 180, 180)
    distanceTxt.Center   = true
    distanceTxt.Outline  = true
    distanceTxt.Visible  = false

    local conn = RunService.RenderStepped:Connect(function()
        if not espEnabled:get() or not player.Character then
            box.Visible = false; hpLine.Visible = false; name.Visible = false; hpNum.Visible = false; distanceTxt.Visible = false
            return
        end

        local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        local head = player.Character:FindFirstChild("Head")

        if not humanoid or not rootPart or not head then return end

        local headPos, headOn = worldToScreen(head.Position)
        local rootPos, rootOn = worldToScreen(rootPart.Position)

        if not headOn or not rootOn then
            box.Visible = false; hpLine.Visible = false; name.Visible = false; hpNum.Visible = false; distanceTxt.Visible = false
            return
        end

        local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local dist = myRoot and math.floor((rootPart.Position - myRoot.Position).Magnitude) or 0

        local baseHeight = math.abs(rootPos.Y - headPos.Y)
        local scale = math.clamp(100 / (dist + 10), 0.3, 2.5)
        local height = baseHeight * scale
        local width = height * 0.7

        local centerX = (headPos.X + rootPos.X) / 2
        local topY = headPos.Y - height * 0.05 * scale
        local bottomY = rootPos.Y + height * 0.05 * scale

        box.Size     = Vector2.new(width, height)
        box.Position = Vector2.new(centerX - width/2, topY)
        box.Visible  = true

        local hpPercent = humanoid.Health / humanoid.MaxHealth
        hpLine.From = Vector2.new(centerX - width/2 - 4, bottomY)
        hpLine.To   = Vector2.new(centerX - width/2 - 4, bottomY - height * hpPercent)
        hpLine.Color = hpPercent > 0.5 and Color3.fromRGB(0, 255, 0) or hpPercent > 0.25 and Color3.fromRGB(255, 200, 0) or Color3.fromRGB(255, 0, 0)
        hpLine.Visible = true

        name.Text     = player.Name
        name.Position = Vector2.new(centerX, topY - 14 * scale)
        name.Size     = math.clamp(13 * scale, 8, 20)
        name.Visible  = true

        hpNum.Text     = math.floor(humanoid.Health)
        hpNum.Position = Vector2.new(centerX + width/2 + 6, bottomY)
        hpNum.Size     = math.clamp(12 * scale, 8, 18)
        hpNum.Visible  = true

        distanceTxt.Text     = dist .. "m"
        distanceTxt.Position = Vector2.new(centerX, bottomY + 3)
        distanceTxt.Size     = math.clamp(10 * scale, 6, 14)
        distanceTxt.Visible  = true
    end)

    espDrawings[player] = {conn, box, hpLine, name, hpNum, distanceTxt}
end

local function clearPlayerESP(player)
    if espDrawings[player] then
        for _, obj in ipairs(espDrawings[player]) do
            if typeof(obj) == "RBXScriptConnection" then obj:Disconnect() else obj.Visible = false end
        end
        espDrawings[player] = nil
    end
end

-- Target GUI update
local function updateTargetDisplay(player)
    if not player or not player.Character then
        targetFrame.Visible = false
        return
    end

    targetFrame.Visible = true

    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local hpPercent = humanoid.Health / humanoid.MaxHealth
        healthFill.Size = UDim2.new(hpPercent, 0, 1, 0)
        healthText.Text = math.floor(humanoid.Health) .. " HP"
    end

    targetName.Text = "TARGET: " .. player.Name:upper()

    local teamName = player.Team and player.Team.Name or "NEUTRAL"
    targetTeam.Text = "TEAM: " .. teamName:upper()
    targetTeam.TextColor3 = player.Team and player.Team.TeamColor.Color or Color3.fromRGB(150, 150, 150)

    local success, url = pcall(function()
        return Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size150x150)
    end)
    profileImage.Image = success and url or ""
end

-- Find closest target near mouse (within FOV)
local function findTarget()
    local mousePos = Vector2.new(Mouse.X, Mouse.Y)
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end

    local closest, closestDist = nil, fovSize:get()

    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer and p.Character and not isSameTeam(p) then
            local part = p.Character:FindFirstChild(aimSettings.aimPart) or p.Character:FindFirstChild("HumanoidRootPart")
            if part then
                local screenPos, onScreen = worldToScreen(part.Position)
                if onScreen then
                    local distToMouse = (screenPos - mousePos).Magnitude
                    if distToMouse <= closestDist then
                        closestDist = distToMouse
                        closest = p
                    end
                end
            end
        end
    end
    return closest
end

-- Aim lock (tween camera + set Mouse.Hit)
local function aimAt(target)
    if not target or not target.Character then return end

    local part = target.Character:FindFirstChild(aimSettings.aimPart) or target.Character:FindFirstChild("HumanoidRootPart")
    if not part then return end

    local targetPos = part.Position
    local currentCFrame = Camera.CFrame
    local targetCFrame = CFrame.new(currentCFrame.Position, targetPos)

    local tweenInfo = TweenInfo.new(aimSettings.smoothing, Enum.EasingStyle.Linear)
    TweenService:Create(Camera, tweenInfo, {CFrame = targetCFrame}):Play()
    Mouse.Hit = CFrame.new(targetPos)
end

-- Main loop
RunService.RenderStepped:Connect(function()
    -- FOV circle
    if aimbotEnabled:get() then
        fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        fovCircle.Radius   = fovSize:get()
        fovCircle.Visible  = true
    else
        fovCircle.Visible = false
    end

    if aimbotEnabled:get() then
        local target = findTarget()
        updateTargetDisplay(target)
        if target then aimAt(target) end
    else
        updateTargetDisplay(nil)
    end
end)

-- ESP toggle
espEnabled.changed:Connect(function(enabled)
    if enabled then
        for _, p in ipairs(Players:GetPlayers()) do createPlayerESP(p) end
        Players.PlayerAdded:Connect(createPlayerESP)
    else
        for p in pairs(espDrawings) do clearPlayerESP(p) end
    end
end)

-- GUI
Iris:Connect(function()
    Iris.Window({"LIFE IN PRISON"})

    Iris.Tree({"MAIN"})
        Iris.Checkbox({"TOGGLE AIMBOT / FOV"}, {isChecked = aimbotEnabled})
        Iris.Text({"AIMBOT: " .. (aimbotEnabled:get() and "ON" or "OFF")})

        Iris.SliderNum({"FOV SIZE"}, {number = fovSize, min = 30, max = 300, increment = 5})
        Iris.Text({"CURRENT FOV: " .. math.floor(fovSize:get())})

        Iris.Checkbox({"ENABLE AUTOKILL"}, {isChecked = autoKillEnabled})
        Iris.Text({"AUTOKILL: " .. (autoKillEnabled:get() and "ON" or "OFF")})

        Iris.Checkbox({"ENABLE ESP"}, {isChecked = espEnabled})
        Iris.Text({"ESP: " .. (espEnabled:get() and "ON" or "OFF")})
    Iris.End()

    Iris.Tree({"TESTING"})
        Iris.Text({"TESTING AREA - ADD STUFF LATER"})
    Iris.End()
end)
